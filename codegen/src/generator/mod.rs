mod ztypes;

use crate::config::Service;
use crate::parser::data::{self, Node};
use anyhow::{format_err, Context, Result};
use heck::ToSnakeCase;
use std::collections::HashSet;
use std::io::Write;

pub(crate) fn generate(output: &mut impl Write, nodes: Vec<Node>, service: &Service) -> Result<()> {
    writeln!(
        output,
        "// This file is autogenerated, do not manually edit.",
    )?;
    writeln!(output, "\n")?;

    if !nodes.is_empty() {
        writeln!(output, "use crate::zbus::proxy;")?;
        writeln!(output, "\n")?;

        for object in nodes {
            let iface = object.interface.clone();
            generate_single_object(output, object, service)
                .with_context(|| format!("Generating interface '{}'", iface))?;
        }
    }

    Ok(())
}

fn generate_single_object(file: &mut impl Write, node: Node, service: &Service) -> Result<()> {
    writeln!(file, "/// Proxy object for `{}`.", node.interface)?;

    writeln!(file, "#[proxy(")?;
    {
        writeln!(file, r#"interface = "{}","#, node.interface)?;
        writeln!(file, r#"gen_blocking = false,"#)?;
        writeln!(file, r#"default_service = "{}","#, service.id)?;
        if node.path == service.hierarchy {
            writeln!(file, r#"default_path = "{}","#, service.hierarchy)?;
        } else {
            writeln!(file, "assume_defaults = false,")?;
        }
    }
    writeln!(file, ")]")?;

    let struct_name = node.struct_name(service);
    writeln!(file, "pub trait {} {{", struct_name,)?;

    if !node.methods.is_empty() {
        let overrides = service.method_overrides();
        emit_methods(file, &node.interface, node.methods, overrides)?;
    }

    if !node.signals.is_empty() {
        emit_signals(file, &node.signals)?;
    }

    if !node.properties.is_empty() {
        let overrides = service.property_overrides();
        emit_properties(file, &node.interface, node.properties, overrides)?;
    }

    writeln!(file, "}}")?;
    writeln!(file)?;

    Ok(())
}

fn emit_methods(
    output: &mut impl Write,
    iface: &str,
    methods: Vec<data::Method>,
    overrides: HashSet<(String, String)>,
) -> Result<()> {
    for method in methods {
        if overrides.contains(&(iface.to_string(), method.name.clone())) {
            continue;
        }

        let directive_link = format!(
            "https://www.freedesktop.org/software/systemd/man/systemd.directives.html#{}()",
            method.name
        );

        let mut inputs = Vec::with_capacity(method.inputs.len());
        for arg in &method.inputs {
            let rtype = ztypes::translate_sig(&arg.1).with_context(|| {
                format_err!(
                    "Failed to generate method '{}' due to unhandled input argument",
                    &method.name,
                )
            })?;

            inputs.push((arg.0.clone(), rtype));
        }

        let translated_sig = translate_sig_output(&method.outputs).with_context(|| {
            format_err!(
                "Failed to generate method '{}' due to unhandled output argument",
                method.name
            )
        })?;

        writeln!(
            output,
            "/// [ðŸ“–]({}) Call interface method `{}`.",
            directive_link, method.name,
        )?;
        let fn_name = match method.name.as_str() {
            "Ref" => "reference".to_string(),
            x => x.to_snake_case(),
        };
        writeln!(output, r#"#[zbus(name = "{}")]"#, method.name)?;
        writeln!(output, "fn {}(&self,", fn_name)?;
        for arg in inputs {
            let mangled_name = match arg.0.as_str() {
                "type" => "typelabel",
                x => x,
            };
            writeln!(output, "  {}: {},", mangled_name, arg.1)?;
        }
        writeln!(output, ") ")?;
        writeln!(output, "-> crate::zbus::Result<{}>;", translated_sig)?;
        writeln!(output)?;
    }

    Ok(())
}

fn emit_signals(output: &mut impl Write, signals: &[data::Signal]) -> Result<()> {
    for entry in signals {
        let mut args = Vec::with_capacity(entry.args.len());
        for (sig, name) in &entry.args {
            let rtype = ztypes::translate_sig(sig).with_context(|| {
                format_err!(
                    "Failed to generate signal '{}' due to unhandled argument",
                    entry.name,
                )
            })?;
            args.push((name, rtype));
        }

        let fn_name = entry.name.to_snake_case();
        writeln!(output, "/// Receive `{}` signal.", entry.name)?;
        writeln!(output, r#"#[zbus(signal, name = "{}")]"#, entry.name)?;
        writeln!(output, "fn {}(&self,", fn_name,)?;
        for (name, rtype) in args {
            let mangled_name = match name.as_str() {
                "type" => "typelabel",
                x => x,
            };
            writeln!(output, "  {}: {},", mangled_name, rtype)?;
        }
        writeln!(output, ") -> crate::zbus::Result<()>;")?;
        writeln!(output)?;
    }
    Ok(())
}

fn emit_properties(
    output: &mut impl Write,
    iface: &str,
    props: Vec<data::Property>,
    overrides: HashSet<(String, String)>,
) -> Result<()> {
    for entry in props {
        if overrides.contains(&(iface.to_string(), entry.name.clone())) {
            continue;
        }

        let fn_name = match entry.name.as_str() {
            "Where" | "Type" => {
                format!("{}_property", entry.name.to_snake_case())
            }
            x => x.to_snake_case(),
        };
        let decoded_type = ztypes::translate_sig(&entry.type_label).with_context(|| {
            format_err!(
                "Failed to generate property '{}' due to unhandled arguments",
                entry.name,
            )
        })?;

        writeln!(output, "/// Get property `{}`.", entry.name)?;
        writeln!(
            output,
            r#"#[zbus(property(emits_changed_signal = "{}"), name = "{}")]"#,
            entry.emits_changed_signal, entry.name,
        )?;
        writeln!(
            output,
            "fn {}(&self) -> crate::zbus::Result<{}>;",
            fn_name, decoded_type,
        )?;
        writeln!(output)?;

        if entry.writable {
            // NOTE(lucab): `set_property_` prefix is ugly, but a shorter `set_`
            // prefix unfortunately will result in a conflict on `SetWallMessage`
            // method.
            writeln!(output, "/// Set property `{}`.", entry.name)?;
            writeln!(output, r#"#[zbus(property, name = "{}")]"#, entry.name)?;
            writeln!(
                output,
                "fn set_property_{}(&self, new_value: {}) -> crate::zbus::Result<()>;",
                entry.name.to_snake_case(),
                decoded_type,
            )?;
            writeln!(output)?;
        }
    }
    Ok(())
}

fn translate_sig_output(outputs: &Vec<(String, String)>) -> Result<String> {
    if outputs.is_empty() {
        return Ok("()".to_string());
    }

    if outputs.len() == 1 {
        return ztypes::translate_sig(&outputs[0].1);
    }

    let mut res = String::new();
    for arg in outputs {
        if !res.is_empty() {
            res.push_str(", ");
        }
        let rtype = ztypes::translate_sig(&arg.1)?;
        res.push_str(&rtype);
    }
    Ok(format!("({})", res))
}
